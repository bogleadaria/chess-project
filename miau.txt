#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <stdbool.h>

#include "game.h"
#include "move_validation.h"
#include "ai.h"

int main()
{

    GameState gs = initializeGame();
    PGN pgn = initializarePGN();
    initializeaza_tabele_negre();

    char start[50], finish[3], fisier[100];
    int x1, y1, x2, y2;

    char event[250];
    printf("Event ");
    fgets(event, sizeof(event), stdin);
    event[strcspn(event, "\n")] = '\0'; // Elimină newline-ul
    strncpy(pgn.event, event, sizeof(pgn.event) - 1);
    pgn.event[sizeof(pgn.event) - 1] = '\0';

    char site[250];
    printf("Site ");
    fgets(site, sizeof(site), stdin);
    site[strcspn(site, "\n")] = '\0'; // Elimină newline-ul
    strncpy(pgn.site, site, sizeof(pgn.site) - 1);
    pgn.site[sizeof(pgn.site) - 1] = '\0';

    char date[50];
    printf("Date ");
    fgets(date, sizeof(date), stdin);
    date[strcspn(date, "\n")] = '\0'; // Elimină newline-ul
    strncpy(pgn.date, date, sizeof(pgn.date) - 1);
    pgn.date[sizeof(pgn.date) - 1] = '\0';

    int round = 0;

    char(white[250]);
    printf("White (nume jucător)\n");
    fgets(white, sizeof(white), stdin);
    white[strcspn(white, "\n")] = '\0'; // Elimină newline-ul
    strncpy(pgn.white, white, sizeof(pgn.white) - 1);
    pgn.white[sizeof(pgn.white) - 1] = '\0';

    char black[250];
    printf("Black (nume jucător)\n");
    fgets(black, sizeof(black), stdin);
    black[strcspn(black, "\n")] = '\0'; // Elimină newline-ul
    strncpy(pgn.black, black, sizeof(pgn.black) - 1);
    pgn.black[sizeof(pgn.black) - 1] = '\0';

    char result[10] = "*";

    printf("\n\n\nAlegeti o culore (alb/negru): ");
    char culoare[10];
    scanf("%s", culoare);
    if (strcmp(culoare, "negru") == 0)
    {
        printf("Veti juca piesele negre.\n");
        gs.culoare_ai = 0; // Alb
        gs.currentPlayer = 0;

        while (1)
        {
            printTabla(gs.tabla, gs.culoare_ai);
            int nr_regi = 0;
            for (int m = 0; m < 8; m++)
                for (int n = 0; n < 8; n++)
                {
                    if (gs.tabla[m][n] == 'R')
                        nr_regi++;
                    if (gs.tabla[m][n] == 'r')
                        nr_regi++;
                }
            if (nr_regi < 2)
            {

                return 0; // jocul s-a terminat, nu mai sunt 2 regi
            }
            printf("Jucător curent: %s\n", gs.currentPlayer ? "Negru (TU)" : "Alb (ENGINE)");

            // Rândul AI-ului (alb)
            round++;
            if (gs.currentPlayer == 0)
            {
                printf("Engine-ul gândește...\n");
                Move best = findBestMove(&gs, gs.culoare_ai);
                if (best.x1 == -1)
                {
                    printf("Nicio mutare validă! Remiză sau mat.\n");
                    break;
                }
                printf("Engine alege: %c%d-%c%d\n",
                       'a' + best.y1, 8 - best.x1, 'a' + best.y2, 8 - best.x2);
                executa_mutare(best.x1, best.y1, best.x2, best.y2, &gs);

                // Verifică șah mat
                if (isCheckmate(&gs))
                {
                    printTabla(gs.tabla, gs.culoare_ai);
                    printf("Șah mat! Alb (ENGINE) câștigă!\n");
                    break;
                }

                // Verifică pat (remiză)
                if (!existaMutareLegala(&gs))
                {
                    if (isInCheck(&gs, gs.currentPlayer))
                    {
                        printf("Eroare logică: ar fi trebuit să fie șah mat!\n");
                    }
                    else
                    {
                        printTabla(gs.tabla, gs.culoare_ai);
                        printf("Remiză prin pat! Nicio mutare legală și regele NU este în șah.\n");
                        break;
                    }
                }

                // Verifică dacă adversarul este în șah după mutare
                if (isInCheck(&gs, gs.currentPlayer))
                {
                    printf("\n\nAtenție: %s este în șah!\n", gs.currentPlayer ? "Negru" : "Alb");
                }

                gs.currentPlayer = !gs.currentPlayer;
                continue;
            }

            if (isInCheck(&gs, gs.currentPlayer))
            {
                int nr_regi = 0;
                for (int m = 0; m < 8; m++)
                    for (int n = 0; n < 8; n++)
                    {
                        if (gs.tabla[m][n] == 'R')
                            nr_regi++;
                        if (gs.tabla[m][n] == 'r')
                            nr_regi++;
                    }
                if (nr_regi < 2)
                {
                    return 0; // jocul s-a terminat, nu mai sunt regi
                }
                else
                {
                    printf("\n\nAtenție: %s este în șah!\n", gs.currentPlayer ? "Negru  (TU)" : "Alb (ENGINE)");
                    // printf("\n\nNu poti muta alta piesa pana nu iesi din șah.");
                    // TODO: verifica daca mutarea viitoare te scoate din șah
                }
            }

            // Rândul omului (negru)
            printf("Introduceți 'save nume_fisier.fen/pgn' pentru a salva,\n");
            printf("'load_state nume_fisier' pentru a încărca un joc dintr-un fisier FEN\n");
            printf("'load_game nume_fisier' pentru a incarca un joc dintr-un fisier PGN\n");
            printf("'exit' pentru a ieși\n");
            printf("sau mutarea (ex: e2 e4): ");

            scanf("%s", start);

            if (strcmp(start, "save") == 0)
            {
                scanf("%s", fisier);
                salveazaJoc(&gs, fisier, &pgn);
                continue;
            }
            else if (strcmp(start, "load_state") == 0)
            {
                scanf("%s", fisier);
                reincepereJoc(&gs, fisier, &pgn, 0); // FEN
                continue;
            }
            else if (strcmp(start, "load_game") == 0)
            {
                scanf("%s", fisier);
                reincepereJoc(&gs, fisier, &pgn, 1); // PGN
                continue;
            }
            else if (strcmp(start, "exit") == 0)
            {
                inchideJoc();
            }

            scanf("%s", finish);
            transformareMiscare(start, finish, &x1, &y1, &x2, &y2, gs.culoare_ai);

            int valid = validareMiscare(x1, y1, x2, y2, &gs);

            if (valid == 1 && !mutareIeseDinSah(x1, y1, x2, y2, &gs))
            {
                // Mutare legală și nu lasă regele în șah
                executa_mutare(x1, y1, x2, y2, &gs);

                // Verifică șah mat
                if (isCheckmate(&gs))
                {
                    printTabla(gs.tabla, gs.culoare_ai);
                    printf("Șah mat! %s câștigă!\n", gs.currentPlayer ? "Negru" : "Alb");
                    break;
                }

                // Verifică pat (remiză)
                if (!existaMutareLegala(&gs))
                {
                    if (isInCheck(&gs, gs.currentPlayer))
                        printf("Eroare logică: ar fi trebuit să fie șah mat!\n");
                    else
                        printf("Remiză prin pat! Nicio mutare legală și regele NU este în șah.\n");
                    break;
                }

                // Verifică dacă adversarul este în șah după mutare
                if (isInCheck(&gs, !gs.currentPlayer))
                    printf("\nAtenție: %s este în șah!\n", gs.currentPlayer ? "Alb" : "Negru");

                gs.currentPlayer = !gs.currentPlayer;
            }
            else if (valid == 0)
            {
                // Mutare invalidă: nu aparține piesei tale sau nu respectă regulile piesei
                char piece = gs.tabla[x1][y1];
                if (piece == ' ' ||
                    (gs.currentPlayer == 0 && islower(piece)) ||
                    (gs.currentPlayer == 1 && isupper(piece)))
                {
                    printf("Jucător greșit! Nu poți muta piesa adversarului.\n");
                }
                else if (piece == 'r' || piece == 'R')
                {
                    // Verifică dacă este rocadă
                    if (validareRocada(x1, y1, x2, y2, &gs) == 1)
                    {
                        executa_mutare(x1, y1, x2, y2, &gs);
                        gs.currentPlayer = !gs.currentPlayer;
                    }
                    else
                    {
                        printf("Mutare invalidă! Nu este rocadă validă.\n");
                    }
                }
                else
                {
                    printf("Mutare invalidă! Nu respectă regulile piesei.\n");
                }
            }
            else if (valid == -1)
            {
                // Mutare ilegală (dacă folosești această valoare)
                printf("Mutare ilegală! Nu poți lăsa regele în șah.\n");
            }
            else
            {
                if (mutareIeseDinSah(x1, y1, x2, y2, &gs))
                {
                    printf("Mutarea nu te scoate din șah.\n");
                }
                else if (validareMiscare(x1, y1, x2, y2, &gs))
                {
                    executa_mutare(x1, y1, x2, y2, &gs);
                }
                else
                {
                    printf("Mutare invalidă! Nu poți lăsa regele în șah.\n");
                }
            }
        }
        if (isCheckmate(&gs))
        {
            if (gs.currentPlayer == 0)
            {
                strcpy(result, "0-1");
            }
            else
            {
                strcpy(result, "1-0");
            }
        }
        else if (esteRemiza(&gs))
        {
            strcpy(result, "1/2-1/2");
        }
    }
    else
    {
        printf("Veti juca piesele albe.\n");
        gs.culoare_ai = 1;    // Negru
        gs.currentPlayer = 0; // Alb

        while (1)
        {

            printTabla(gs.tabla, gs.culoare_ai);
            int nr_regi = 0;
            for (int m = 0; m < 8; m++)
                for (int n = 0; n < 8; n++)
                {
                    if (gs.tabla[m][n] == 'R')
                        nr_regi++;
                    if (gs.tabla[m][n] == 'r')
                        nr_regi++;
                }
            if (nr_regi < 2)
            {
                return 0; // jocul s-a terminat, nu mai sunt regi
            }
            printf("Jucător curent: %s\n", gs.currentPlayer ? "Negru (ENGINE)" : "Alb (TU)");

            // Rândul AI-ului (negru)
            if (gs.currentPlayer == 1)
            {
                printf("Engine-ul gândește...\n");
                Move best = findBestMove(&gs, gs.culoare_ai);
                if (best.x1 == -1)
                {
                    printf("Nicio mutare validă! Remiză sau mat.\n");
                    break;
                }
                printf("Engine alege: %c%d-%c%d\n",
                       'a' + best.y1, 8 - best.x1, 'a' + best.y2, 8 - best.x2);
                executa_mutare(best.x1, best.y1, best.x2, best.y2, &gs);

                // Verifică șah mat
                if (isCheckmate(&gs))
                {
                    printTabla(gs.tabla, gs.culoare_ai);
                    printf("Șah mat! Negru (ENGINE) câștigă!\n");
                    break;
                }

                // Verifică pat (remiză)
                if (!existaMutareLegala(&gs))
                {
                    if (isInCheck(&gs, gs.currentPlayer))
                    {
                        printf("Eroare logică: ar fi trebuit să fie șah mat!\n");
                    }
                    else
                    {
                        printTabla(gs.tabla, gs.culoare_ai);
                        printf("Remiză prin pat! Nicio mutare legală și regele NU este în șah.\n");
                        break;
                    }
                }

                // Verifică dacă adversarul este în șah după mutare
                if (isInCheck(&gs, gs.currentPlayer))
                {
                    printf("\n\nAtenție: %s este în șah!\n", gs.currentPlayer ? "Negru" : "Alb");
                }

                gs.currentPlayer = !gs.currentPlayer;
                continue;
            }

            if (isInCheck(&gs, gs.currentPlayer))
            {
                int nr_regi = 0;
                for (int m = 0; m < 8; m++)
                    for (int n = 0; n < 8; n++)
                    {
                        if (gs.tabla[m][n] == 'R')
                            nr_regi++;
                        if (gs.tabla[m][n] == 'r')
                            nr_regi++;
                    }
                if (nr_regi < 2)
                {
                    return 0; // jocul s-a terminat, nu mai sunt regi
                }
                else
                {
                    printf("\n\nAtenție: %s este în șah!\n\n\n", gs.currentPlayer ? "Negru (ENGINE)" : "Alb (TU)");
                    // printf("\n\nNu poti muta alta piesa pana nu iesi din șah.");
                    // TODO: verifica daca mutarea viitoare te scoate din șah
                }
            }

            // Rândul omului (alb)
            round++;
            printf("Introduceți 'save nume_fisier.fen/pgn' pentru a salva,\n");
            printf("'load_state nume_fisier' pentru a încărca un joc dintr-un fisier FEN\n");
            printf("'load_game nume_fisier' pentru a incarca un joc dintr-un fisier PGN\n");
            printf("'exit' pentru a ieși\n");
            printf("sau mutarea (ex: e2 e4): ");

            scanf("%s", start);

            if (strcmp(start, "save") == 0)
            {
                pgn.round = round;
                strcpy(pgn.result, result);
                scanf("%s", fisier);
                salveazaJoc(&gs, fisier, &pgn);
                continue;
            }
            else if (strcmp(start, "load_state") == 0)
            {
                scanf("%s", fisier);
                reincepereJoc(&gs, fisier, &pgn, 0); // FEN
                continue;
            }
            else if (strcmp(start, "load_game") == 0)
            {
                scanf("%s", fisier);
                reincepereJoc(&gs, fisier, &pgn, 1); // FEN
                continue;
            }
            else if (strcmp(start, "exit") == 0)
            {
                inchideJoc();
            }

            scanf("%s", finish);
            transformareMiscare(start, finish, &x1, &y1, &x2, &y2, gs.culoare_ai);

            int valid = validareMiscare(x1, y1, x2, y2, &gs);

            if (valid == 1 && !mutareIeseDinSah(x1, y1, x2, y2, &gs))
            {
                // Mutare legală și nu lasă regele în șah
                executa_mutare(x1, y1, x2, y2, &gs);

                // Verifică șah mat
                if (isCheckmate(&gs))
                {
                    printTabla(gs.tabla, gs.culoare_ai);
                    printf("Șah mat! %s câștigă!\n", gs.currentPlayer ? "Negru" : "Alb");
                    break;
                }

                // Verifică pat (remiză)
                if (!existaMutareLegala(&gs))
                {
                    if (isInCheck(&gs, gs.currentPlayer))
                        printf("Eroare logică: ar fi trebuit să fie șah mat!\n");
                    else
                        printf("Remiză prin pat! Nicio mutare legală și regele NU este în șah.\n");
                    break;
                }

                // Verifică dacă adversarul este în șah după mutare
                if (isInCheck(&gs, !gs.currentPlayer))
                    printf("\nAtenție: %s este în șah!\n", gs.currentPlayer ? "Alb" : "Negru");

                gs.currentPlayer = !gs.currentPlayer;
            }
            else if (valid == 0)
            {
                // Mutare invalidă: nu aparține piesei tale sau nu respectă regulile piesei
                char piece = gs.tabla[x1][y1];
                if (piece == ' ' ||
                    (gs.currentPlayer == 0 && islower(piece)) ||
                    (gs.currentPlayer == 1 && isupper(piece)))
                {
                    printf("Jucător greșit! Nu poți muta piesa adversarului.\n");
                }
                else if (piece == 'r' || piece == 'R')
                {
                    // Verifică dacă este rocadă
                    if (validareRocada(x1, y1, x2, y2, &gs) == 1)
                    {
                        executa_mutare(x1, y1, x2, y2, &gs);
                        gs.currentPlayer = !gs.currentPlayer;
                    }
                    else
                    {
                        printf("Mutare invalidă! Nu este rocadă validă.\n");
                    }
                }
                else
                {
                    printf("Mutare invalidă! Nu respectă regulile piesei.\n");
                }
            }
            else if (valid == -1)
            {
                // Mutare ilegală (dacă folosești această valoare)
                printf("Mutare ilegală! Nu poți lăsa regele în șah.\n");
            }
            else
            {
                if (mutareIeseDinSah(x1, y1, x2, y2, &gs))
                {
                    printf("Mutarea nu te scoate din șah.\n");
                }
                else if (validareMiscare(x1, y1, x2, y2, &gs))
                {
                    executa_mutare(x1, y1, x2, y2, &gs);
                }
                else
                {
                    printf("Mutare invalidă! Nu poți lăsa regele în șah.\n");
                }
            }
        }
        if (isCheckmate(&gs))
        {
            if (gs.currentPlayer == 0)
            {
                strcpy(result, "0-1");
            }
            else
            {
                strcpy(result, "1-0");
            }
        }
        else if (esteRemiza(&gs))
        {
            strcpy(result, "1/2-1/2");
        }
    }

    return 0;
}